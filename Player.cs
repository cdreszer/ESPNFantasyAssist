using System;
using System.Linq;
using System.Collections.Generic;

/// NOTE TO SELF: disable codelens (references of methods/variables) in Visual Studio Code settings.
namespace ESPNFantasyAssist {

    public class Player : IEquatable<Player>, IEqualityComparer<Player> {
        private string id;
        private string name;
        private string team;
        private string position;
        private bool isBatter;
        private Dictionary<string, double> activeTotals;
        private Dictionary<string, double> inactiveTotals;
        private List<Dictionary<string, double>> weeklyTotals;
        public int lastScoringPeriodUpdated;

        // getters and setters (autogenerated)
        // should probably be modifying ID in setters
        public string Name { get => name; 
        set 
        {
            name = value;
            Id = value + Position + Team + IsBatter;
        }}
        public string Team { get => team; 
        set 
        {
            team = value;
            Id = Name + Position + value + IsBatter;
        }}
        public string Position { get => position; 
        set {
            position = value;
            Id = Name + value + Team + IsBatter;
        }}
        public bool IsBatter { get => isBatter; 
        set {
            isBatter = value;
            Id = Name + Position + Team + value; 
        }}

        public Dictionary<string, double> ActiveTotals { get => activeTotals; set => activeTotals = value; }
        public Dictionary<string, double> InactiveTotals { get => inactiveTotals; set => inactiveTotals = value; }
        public List<Dictionary<string, double>> WeeklyTotals { get => weeklyTotals; set => weeklyTotals = value; }
        public string Id { get => id; set => id = value; }

        public Player(string name, string team, string position, bool isBatter) {
            Name = name;
            Team = team;
            Position = position;
            IsBatter = isBatter;
            Id = name + position + team + isBatter;

            // Starts player out with 0 for each category.
            if (IsBatter) {
                ActiveTotals = Util.GetDefaultBatterStats();
                InactiveTotals = Util.GetDefaultBatterStats();
            }
            else {
                ActiveTotals = Util.GetDefaultPitcherStats();
                InactiveTotals = Util.GetDefaultPitcherStats();
            }
        }

        /// Updates active totals with daily totals.
        public void UpdateActiveTotals(Dictionary<string, double> dailyTotal) {
            if (dailyTotal != null) {
                ActiveTotals = UpdateTotals(ActiveTotals, dailyTotal);
            }
        }

        /// Updates inactive totals with daily totals.
        public void UpdateInactiveTotals(Dictionary<string, double> dailyTotal) {
            if (dailyTotal != null) {
                InactiveTotals = UpdateTotals(InactiveTotals, dailyTotal);
            }
        }

        /// Updates either active or inactive totals for the player.
        /// Done by incrementing total with daily totals.
        ///
        /// Example daily totals: 
        ///      Hits: 1, AB: 3, R: 1, HR: 1, RBI: 1, SB: 0 
        ///      IP: 7, H: 5, ER: 2, BB: 2, K: 9, W: 1, SV: 0
        public Dictionary<string, double> UpdateTotals(Dictionary<string, double> totals, Dictionary<string, double> dailyTotal) {
            if (totals == null) {
                totals = dailyTotal;
            }
            else {
                // Updates each key, value pair in the totals
                foreach (string key in dailyTotal.Keys) {
                    // Adds daily value into the total.
                    if (totals.TryGetValue(key, out double value)) {
                        totals[key] = value + dailyTotal[key];
                    }
                    else {
                        totals.Add(key, dailyTotal[key]);
                    }
                }
            }

            return totals;
        }

        /// Call before returning stats.
        /// NOT CURRENTLY USED.
        public void CalculateAdditionalStats() {
            // Print out AVG and removes proceeding 0; 0.287 -> .287
            if (IsBatter) {
                activeTotals.Add("AVG", Util.CalculateAverage(activeTotals["H"], activeTotals["AB"]));
                inactiveTotals.Add("AVG", Util.CalculateAverage(inactiveTotals["H"], inactiveTotals["AB"]));
            }
            else {
                activeTotals.Add("ERA", Util.CalculateERA(activeTotals["ER"], activeTotals["IP"]));
                activeTotals.Add("WHIP", Util.CalculateWHIP(activeTotals["BB"], activeTotals["H"], activeTotals["IP"]));
                inactiveTotals.Add("ERA", Util.CalculateERA(inactiveTotals["ER"], inactiveTotals["IP"]));
                inactiveTotals.Add("WHIP", Util.CalculateWHIP(inactiveTotals["BB"], inactiveTotals["H"], inactiveTotals["IP"]));
            }
        }

        /// Prints active stats.
        public void PrintActiveStats() {
            PrintStats(ActiveTotals);
        }

        /// Print inactive stats.
        public void PrintInactiveStats() {
            // Dont print if havent accumulated inactiveStats
            if (InactiveTotals.Values.Where(val => val == 0.0).ToList().Count != InactiveTotals.Values.Count) {
                PrintStats(InactiveTotals);
            }
        }

        /// Prints out stats given the totals (active/inactive)
        public void PrintStats(Dictionary<string, double> totals) {
            // Retrieves correct stat categories
            string[] categories = IsBatter ? Util.BatterCategories : Util.PitcherCategories;
            
            // Deal with name and tabs
            if (Name.Length < 8) 
                Console.Write(Name + ":\t\t\t");
            else if (Name.Length < 15) 
                Console.Write(Name + ":\t\t");
            else
                Console.Write(Name + ":\t");

            // Prints out total for each stat category
            foreach (string key in categories) {
                if (totals.TryGetValue(key, out double value)) {
                    Console.Write(value + "\t");
                }
                else {
                    Console.Write("0\t");
                }
            }

            // Print out AVG and removes proceeding 0; 0.287 -> .287
            if (IsBatter) {
                Console.Write(Util.CalculateAverage(totals["H"], totals["AB"]).ToString("#.000") + "\n");
            }
            // Print out ERA, WHIP and round to two decimals
            else {
                Console.Write(Util.CalculateERA(totals["ER"], totals["IP"]).ToString("#.00")
                + "\t" + Util.CalculateWHIP(totals["BB"], totals["H"], totals["IP"]).ToString("#.00")
                + "\n");
            }
        }

        /// Returns a list of stats with player name as the first entry
        public IList<object> GetStatsAsList(bool activeStats) {
            string[] statCategories = IsBatter ? Util.BatterCategories : Util.PitcherCategories;

            List<object> stats = new List<object>();
            stats.Add(Name);

            foreach(string key in statCategories) {
                if (activeStats) {
                    stats.Add(ActiveTotals[key]);
                }
                else {
                    stats.Add(InactiveTotals[key]);
                }
            }

            Dictionary<string, double> totals = activeStats ? ActiveTotals : InactiveTotals;

            // Adds average
            if (IsBatter) {
                stats.Add(Util.CalculateAverage(totals["H"], totals["AB"]).ToString("#.000"));
            }
            // Adds ERA and WHIP
            else {
                stats.Add(Util.CalculateERA(totals["ER"], totals["IP"]).ToString("#.00"));
                stats.Add(Util.CalculateWHIP(totals["BB"], totals["H"], totals["IP"]).ToString("#.00"));
            }

            return stats;
        }

        /// Checks if the player has stats or if their stats are equivalent to the default entry (all 0s)
        public bool HasStats(bool activeStats) {
            if (activeStats) {
                return (ActiveTotals.Values.Where(val => val == 0.0).ToList().Count != ActiveTotals.Values.Count);
            }
            else {
                return (InactiveTotals.Values.Where(val => val == 0.0).ToList().Count != InactiveTotals.Values.Count);
            }
        }

        /// overrides equitables equal method
        public bool Equals(Player other) {
            if (other == null) {
                return false;
            }

            return this.name.Equals(other.name) && this.position.Equals(other.position) && this.team.Equals(other.team) && this.isBatter == other.isBatter;
        }

        /// overrides IEqualityComparer equal method
        public bool Equals(Player player1, Player player2) {
            return (player1.Name.Equals(player2.Name)) && (player2.Name.Equals(player2.IsBatter));
        }

        /// overrides IEqualityComparer gethashcode method
        public int GetHashCode(Player player) {
            return Id.GetHashCode();
        }
    }
}